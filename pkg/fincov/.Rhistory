dat <- read.csv(file, header=TRUE)
dat <- xts(dat[,3:6], order.by=as.Date(dat[,1]))
dat <- dat[-(1:60),]
head(dat)
xyplot(dat)
x <- sqrt(qchisq(0.975, ncol(dat)))
outliers <- detectOutliers(dat)
# square root of classic mahalanobis distances
cl_md <- sqrt(outliers$classical_mahalanobis)
# square root of robust mahalanobis distances
rob_md <- sqrt(outliers$robust_mahalanobis)
plot(cl_md)
text(x=which(cl_md > x), y=cl_md[which(cl_md > x)], labels=which(cl_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
plot(rob_md)
text(x=which(rob_md > x), y=rob_md[which(rob_md > x)], labels=which(rob_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
outliers$classical_mahalanobis[1]
outliers$classical_mahalanobis
length(outliers$classical_mahalanobis)
dim(dat)
index(dat)
names(outliers$classical_mahalanobis)
which(rob_md > x)
file <- "/Users/rossbennett/Documents/UW Comp Fin/Portfolio-Optimization-Asset-Management/Material/chap6/normal.vs.hectic.ts.csv"
library(covariance)
dat <- read.csv(file, header=TRUE)
dat <- xts(dat[,3:6], order.by=as.Date(dat[,1]))
dat <- dat[-(1:60),]
head(dat)
xyplot(dat)
outliers <- detectOutliers(dat)
x <- outliers$threshold
x
# square root of classic mahalanobis distances
cl_md <- sqrt(outliers$classical_mahalanobis)
# square root of robust mahalanobis distances
rob_md <- sqrt(outliers$robust_mahalanobis)
plot(cl_md)
text(x=which(cl_md > x), y=cl_md[which(cl_md > x)], labels=which(cl_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
plot(rob_md)
text(x=which(rob_md > x), y=rob_md[which(rob_md > x)], labels=which(rob_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
cl_outlier_dates <- cl_md[which(cl_md > x)]
cl_outlier_dates
cl_outlier_dates <- names(cl_md[which(cl_md > x)])
cl_md <- sqrt(outliers$classical_mahalanobis)
cl_outlier_dates <- names(cl_md[which(cl_md > x)])
# square root of robust mahalanobis distances
rob_md <- sqrt(outliers$robust_mahalanobis)
rob_outlier_dates <- names(rob_md[which(rob_md > x)])
rob_outlier_dates
plot(cl_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(cl_md > x), y=cl_md[which(cl_md > x)], labels=which(cl_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
plot(rob_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(rob_md > x), y=rob_md[which(rob_md > x)], labels=which(rob_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
xyplot(dat)
cl_outlier_dates
xyplot(dat)
abline(v=cl_outlier_dates)
abline(v=as.Date(cl_outlier_dates))
xyplot(dat)
abline(v=as.Date(cl_outlier_dates))
xyplot(dat, panel=function(...){
panel.abline(v=as.Date(cl_outlier_dates))
panel.xyplot(...)
})
abline(v=as.Date(cl_outlier_dates))
xyplot(dat, panel=function(...){
panel.abline(v=as.Date(cl_outlier_dates))
panel.xyplot(...)
})
plot(rob_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(rob_md > x), y=rob_md[which(rob_md > x)], labels=which(rob_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
xyplot(dat, panel=function(...){
panel.abline(v=as.Date(cl_outlier_dates))
panel.xyplot(...)
})
dat[as.Date(cl_outlier_dates)]
dat[as.Date(rob_outlier_dates)]
# xyplot with vertical lines at outlier dates
xyplot(dat, panel=function(...){
panel.abline(v=as.Date(rob_outlier_dates))
panel.xyplot(...)
})
xyplot(dat, panel=function(...){
panel.abline(v=as.Date(rob_outlier_dates))
panel.xyplot(...)
})
dat[as.Date(rob_outlier_dates)]
source('~/devel/R/covariance/R/outlier.R', echo=TRUE)
library(covariance)
xyplot(cbind(cl_md, rob_md))
file <- "/Users/rossbennett/Documents/UW Comp Fin/Portfolio-Optimization-Asset-Management/Material/chap6/normal.vs.hectic.ts.csv"
dat <- read.csv(file, header=TRUE)
dat <- xts(dat[,3:6], order.by=as.Date(dat[,1]))
dat <- dat[-(1:60),]
head(dat)
xyplot(dat)
outliers <- detectOutliers(dat)
x <- outliers$threshold
# square root of classic mahalanobis distances
cl_md <- sqrt(outliers$classical_mahalanobis)
cl_outlier_dates <- names(cl_md[which(cl_md > x)])
# square root of robust mahalanobis distances
rob_md <- sqrt(outliers$robust_mahalanobis)
rob_outlier_dates <- names(rob_md[which(rob_md > x)])
plot(cl_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(cl_md > x), y=cl_md[which(cl_md > x)], labels=which(cl_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
plot(rob_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(rob_md > x), y=rob_md[which(rob_md > x)], labels=which(rob_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
xyplot(cbind(cl_md, rob_md))
xyplot(rbind(cl_md, rob_md))
plot.covfm
ddplot.covfm
robustbase:::ddplot.covfm
robust:::ddPlot.covfm
xyplot(rob_md ~ cl_md)
xyplot(cbind(rob_md, cl_md))
xyplot(rbind(rob_md, cl_md))
xyplot(as.data.frame(cbind(rob_md, cl_md)))
library(covariance)
file <- "/Users/rossbennett/Documents/UW Comp Fin/Portfolio-Optimization-Asset-Management/Material/chap6/normal.vs.hectic.ts.csv"
dat <- read.csv(file, header=TRUE)
dat <- xts(dat[,3:6], order.by=as.Date(dat[,1]))
dat <- dat[-(1:60),]
head(dat)
xyplot(dat)
outliers <- detectOutliers(dat)
x <- outliers$threshold
# square root of classic mahalanobis distances
cl_md <- sqrt(outliers$classical_mahalanobis)
cl_outlier_dates <- names(cl_md[which(cl_md > x)])
x
# square root of classic mahalanobis distances
cl_md <- sqrt(outliers$classical_mahalanobis)
cl_outlier_dates <- names(cl_md[which(cl_md > x)])
# square root of robust mahalanobis distances
rob_md <- sqrt(outliers$robust_mahalanobis)
rob_outlier_dates <- names(rob_md[which(rob_md > x)])
plot(cl_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(cl_md > x), y=cl_md[which(cl_md > x)], labels=which(cl_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
plot(rob_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(rob_md > x), y=rob_md[which(rob_md > x)], labels=which(rob_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
# xyplot with vertical lines at outlier dates
xyplot(dat, panel=function(...){
panel.abline(v=as.Date(cl_outlier_dates))
panel.xyplot(...)
})
# actual data of the outlier dates
dat[as.Date(cl_outlier_dates)]
# xyplot with vertical lines at outlier dates
xyplot(dat, panel=function(...){
panel.abline(v=as.Date(rob_outlier_dates))
panel.xyplot(...)
})
# actual data of the outlier dates
dat[as.Date(rob_outlier_dates)]
# outliers$classical_mahalanobis
# length(outliers$classical_mahalanobis)
# dim(dat)
library(covariance)
outliers <- detectOutliers(dat)
library(covariance)
outliers <- detectOutliers(dat)
library(covariance)
outliers <- detectOutliers(dat)
outliers
m_dat <- data.frame(robust=outliers$robust_mahalanobis, classical=outliers$classical_mahalanobis)
View(m_dat)
xyplot(m_dat)
parallel(m_dat)
parallelplot(m_dat)
xyplot(m_dat)
xyplot(outliers$robust_mahalanobis)
outliers$robust_mahalanobis
xyplot(as.xts(outliers$robust_mahalanobis))
idx <- 1:nrow(dat)
xyplot(sqrt(outliers$robust_mahalanobis)~idx)
xyplot(sqrt(outliers$robust_mahalanobis)~idx|sqrt(outliers$classical_mahalanobis)~idx)
xyplot(cbind(sqrt(outliers$robust_mahalanobis), sqrt(outliers$classical_mahalanobis))~idx)
xyplot(cbind(sqrt(outliers$robust_mahalanobis), sqrt(outliers$classical_mahalanobis))~idx)
xyplot(m_dat~idx)
robust:::ddPlot.covfm
plot.covfm
distancePlot.covfm
plot(cl_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(cl_md > x), y=cl_md[which(cl_md > x)], labels=which(cl_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
plot(rob_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(rob_md > x), y=rob_md[which(rob_md > x)], labels=which(rob_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
par(mfrow=c(1,2))
plot(cl_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(cl_md > x), y=cl_md[which(cl_md > x)], labels=which(cl_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
plot(rob_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(rob_md > x), y=rob_md[which(rob_md > x)], labels=which(rob_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
par(mfrow=c(1,2))
plot(rob_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(rob_md > x), y=rob_md[which(rob_md > x)], labels=which(rob_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
plot(cl_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(cl_md > x), y=cl_md[which(cl_md > x)], labels=which(cl_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
par(mfrow=c(1,1))
layout(matrix(c(1,1,2,2), 2, 2, byrow = TRUE))
layout.show()
layout(matrix(c(1,2, 1,2), 2, 2, byrow = TRUE))
layout.show()
plot(rob_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(rob_md > x), y=rob_md[which(rob_md > x)], labels=which(rob_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
plot(cl_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(cl_md > x), y=cl_md[which(cl_md > x)], labels=which(cl_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
matrix(c(1,2, 1,2), 2, 2, byrow = TRUE)
layout(matrix(c(1,2, 1,2), 2, 2, byrow = TRUE))
layout.show()
plot(rob_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(rob_md > x), y=rob_md[which(rob_md > x)], labels=which(rob_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
plot(cl_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(cl_md > x), y=cl_md[which(cl_md > x)], labels=which(cl_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
# par(mfrow=c(1,1))
plot(rob_md, ylab="Square Root of Mahalanobis Distance")
text(x=which(rob_md > x), y=rob_md[which(rob_md > x)], labels=which(rob_md > x), pos=4, cex=0.8)
abline(h=x, lty=2)
cl_md <- sqrt(outliers$classical_mahalanobis)
# square root of robust mahalanobis distances
rob_md <- sqrt(outliers$robust_mahalanobis)
xyplot(y=cl_md, x=idx)
xyplot(y=cl_md, x=idx, panel=function(x, y){
panel.xyplot()
})
xyplot(cl_md~idx, panel=function(x, y){
panel.xyplot()
})
robust:::distancePlot.covfm
library(covariance)
library(covariance)
file <- "/Users/rossbennett/Documents/UW Comp Fin/Portfolio-Optimization-Asset-Management/Material/chap6/normal.vs.hectic.ts.csv"
dat <- read.csv(file, header=TRUE)
dat <- xts(dat[,3:6], order.by=as.Date(dat[,1]))
dat <- dat[-(1:60),]
head(dat)
xyplot(dat)
library(lattice)
xyplot(dat)
outliers <- detectOutliers(dat)
outliers
x <- outliers$threshold
m_dat <- data.frame(robust=outliers$robust_mahalanobis, classical=outliers$classical_mahalanobis)
idx <- 1:nrow(dat)
xyplot(m_dat~idx)
m_dat
xyplot(m_dat[,1]~idx)
xyplot(m_dat~idx, layout=c(1,2))
xyplot(m_dat[,1]~idx, layout=c(1,2))
xyplot(m_dat[,1]~idx, layout=c(2,1))
xyplot(m_dat[,1]~idx, layout=c(2,1))
xyplot(m_dat, layout=c(2,1))
factor(m_dat[,1], levels="robust")
m_dat[,1]
paste(dir,file, sep="/")
dir <- "/Users/rossbennett/Documents/UW Comp Fin/Portfolio-Optimization-Asset-Management/Material/chap6"
file <- "hfunds5.ue.ts.csv"
paste(dir,file, sep="/")
dat <- read.csv(paste(dir,file, sep="/"), header=TRUE)
head(dat)
dat <- as.data.frame(dat)
name <- names(dat)
name
dat <- read.csv(paste(dir,file, sep="/"), header=TRUE)
dat <- dat[,-1]
head(dat)
#**********************************************************
#Data preparation
#**********************************************************
#If dat is time series convert back from dataframe object
dat <- as.data.frame(dat)
name <- names(dat)
View(dat)
dat <- as.data.frame(dat)
name <- names(dat)
#Order data: Group by number of missing values, missing first
dat <- as.data.frame(ifelse(as.matrix(dat) == -99, NA, as.matrix(dat[,])))
View(dat)
View(dat)
View(dat)
dat <- dat[,names(-sort(apply (is.na(dat), 2, sum)))]
View(dat)
View(dat)
#Asset names
asset.names <- names(dat)
#Length of longest time series
dim(dat)
# Could also do nrow(dat[, 1])
T.N <- dim(dat)[1]
apply(is.na(dat), 2, sum)
#Number of observations per asset
S.j <- T.N - sort(apply(is.na(dat), 2, sum))
S.j
unique(S.j - T.N)
-unique(S.j - T.N)
S.jn <- -unique(S.j - T.N)
apply(is.na(dat), 2, sum)
sort(apply(is.na(dat), 2, sum))
table(sort(apply(is.na(dat), 2, sum)))
as.vector(table(sort(apply(is.na(dat), 2, sum))))
S.jn
S.jn[J]
S.jn <- -unique(S.j - T.N)
#Groups of assets with equal length: N1,..,Nj
N <- as.vector(table(sort(apply(is.na(dat), 2, sum))))
#Number of assets groups with equal length
J <- length(N)
dat.trunc <- dat[(S.jn[J] + 1):T.N, ]
View(dat.trunc)
prec = 4
step.reg = TRUE
final.alg = "Adaptive"
efficiency = 0.95
estim = "auto"
quan = .99
tune = 0.95
final.alg
E.trunc <- apply(dat.trunc, 2, mean)
colMeans(dat.trunc)
E.trunc
dat
lapply(dat.trunc, function(y, x) lmRob(y~1, control=x)$coef, x=control.rob)
library(robust) # for lmRob
lapply(dat.trunc, function(y, x) lmRob(y ~ 1, control=x)$coef, x=control.rob)
control.rob <- lmRob.control(final.alg=final.alg, efficiency=efficiency)
lapply(dat.trunc, function(y, x) lmRob(y ~ 1, control=x)$coef, x=control.rob)
E.trunc.rob <- as.vector(unlist(lapply(dat.trunc, function(y, x) lmRob(y ~ 1, control=x)$coef, x=control.rob)))
E.full.rob <- as.vector(unlist(lapply(dat, function(y,x) lmRob(y ~ 1, control=x, na.action=na.exclude)$coef, x=control.rob)))
E.trunc.rob
E.full.rob
Std.trunc <- sqrt(apply(dat.trunc, 2, var))
Std.full <- sqrt(apply(na.omit(dat), 2, var))
Std.trunc
Std.full
apply(dat, 2, sd, na.rm=TRUE)
apply(dat.trunc, 2, sd)
J
estim
covRob
E <- vector("list", J)
V <- vector("list", J)
#Robust/Bayes
E.rob <- vector("list", J)
V.rob <- vector("list", J)
V.rob.bayes <- vector("list", J)
Std.full.rob
dat.trunc <- dat[(S.jn[J] + 1):T.N, ]
#Set robust controls for lmRob
control.rob <- lmRob.control(final.alg=final.alg, efficiency=efficiency)
#Mean
E.trunc <- apply(dat.trunc, 2, mean)
# E.trunc <- colMeans(dat.trunc)
E.full <- apply(dat, 2, mean, na.rm=TRUE)
# E.full <- colMeans(dat, na.rm=TRUE)
#Mean robust
E.trunc.rob <- as.vector(unlist(lapply(dat.trunc, function(y, x) lmRob(y ~ 1, control=x)$coef, x=control.rob)))
E.full.rob <- as.vector(unlist(lapply(dat, function(y,x) lmRob(y ~ 1, control=x, na.action=na.exclude)$coef, x=control.rob)))
#Standard Deviation
Std.trunc <- sqrt(apply(dat.trunc, 2, var))
# Std.trunc <- apply(dat.trunc, 2, sd)
Std.full <- sqrt(apply(na.omit(dat), 2, var))
# Std.full <- apply(dat, 2, sd, na.rm=TRUE)
#Standard Deviation robust
# this regression is already run to get the Mean robust, can we just run it one time
Std.trunc.rob <- as.vector(unlist(lapply(dat.trunc, function(y,x) lmRob(y ~ 1, control=x)$scale, x=control.rob)))
Std.full.rob <- as.vector(unlist(lapply(dat, function(y,x) lmRob(y ~ 1, control=x, na.action=na.exclude)$scale, x=control.rob)))
E <- vector("list", J)
V <- vector("list", J)
#Robust/Bayes
E.rob <- vector("list", J)
V.rob <- vector("list", J)
V.rob.bayes <- vector("list", J)
S.j
T.N
S.jn[1]
(S.j - T.N) == S.jn[1]
# time seres
dat.tmp <- data.frame(dat[, (S.j - T.N) == S.jn[1]])
dat.tmp
E[[1]] <- apply(dat.tmp, 2, mean)
colMeans(dat.tmp)
dat.tmp
V[[1]] <- var(dat.tmp)
V[[1]]
ncol(dat.tmpP
ncol(dat.tmp)
if(dim(dat.tmp)[2] < 2){
#Robust mean from fitting the intercept
E.rob[[1]] <- as.vector(lmRob(dat.tmp[,1] ~ 1, control=control.rob)$coef)
V.rob[[1]] <- scaleTau2(as.matrix(dat.tmp))^2
}else{
E.rob[[1]] <- as.vector(unlist(lapply(dat.tmp,function(y,x) lmRob(y ~ 1, control=x, na.action=na.exclude)$coef, x=control.rob)))
V.rob[[1]] <- covRob(dat.tmp, estim=estim, quan=quan)$cov
}
V.rob
V.rob[[1]]
scaleTau2
scaleTau2(as.matrix(dat.tmp))^2
covRob(dat.tmp, estim=estim, quan=quan)$cov
J
S.jn
T.N
j=2
iter.N <- sum(N[1:(j-1)])
iter.Nj <- iter.N + N[j]
Sj.min <- max(iter.N, sum(N) - iter.N + 2)
iter.N
N
iter.Nj <- iter.N + N[j]
Sj.min <- max(iter.N, sum(N) - iter.N + 2)
Sj.min
sum(N)
sum(N) - iter.N + 2
S.j[j]
Sj.min
alpha.vec <- rep(NA, N[j])
beta.mat <- matrix(NA, N[j], iter.N)
res.mat <- matrix(NA, T.N - S.jn[j], N[j])
Sigma.mat <- matrix(NA, N[j], N[j])
#Robust
alpha.vec.rob <- rep(NA, N[j])
beta.mat.rob <- matrix(NA, N[j], iter.N)
res.mat.rob <- matrix(NA, T.N - S.jn[j], N[j])
Sigma.mat.rob <- matrix(NA, N[j], N[j])
iter.N
(S.jn[j-1] + 1)
T.N
dat.tmp <- data.frame(dat[(S.jn[j-1] + 1):T.N, 1:iter.N])
#Non Robust
E.j <- as.vector(apply(dat.tmp, 2, mean))
names(E.j) <- names(dat.tmp)
#Robust
if(dim(dat.tmp)[2] < 2){
E.j.rob <- as.vector(lmRob(dat.tmp[,1] ~ 1, control=control.rob)$coef)
}else{
E.j.rob <- as.vector(unlist(lapply(dat.tmp,function(y, x) lmRob(y ~ 1, control=x, na.action=na.exclude)$coef, x=control.rob)))
}
names(E.j.rob) <- names(dat.tmp)
#Data for regression dat_[j-1] (all data to left truncated)
x <- as.data.frame(dat[(S.jn[j]+1):T.N, 1:iter.N])
y <- as.data.frame(dat[(S.jn[j]+1):T.N, (iter.N+1):iter.Nj])
names(y) <- names(dat[(iter.N+1):iter.Nj])
View(x)
View(y)
if(dim(x)[2] < 2){
E.j.trunc.rob <- as.vector(lmRob(x[,1] ~ 1, control=control.rob)$coef)
V.j.trunc.rob <- scaleTau2(as.matrix(x))^2
}else{
E.j.trunc.rob <- as.vector(unlist(lapply(dat.tmp, function(y, x) lmRob(y ~ 1, control=x, na.action=na.exclude)$coef, x=control.rob)))
V.j.trunc.rob <- covRob(x, estim=estim, quan=quan)$cov
}
E.j.trunc.rob
V.j.trunc.rob
N
x
y[i]
i=1
dat.lm <- data.frame(y[i], x)
dat.lm
res.reg
res.reg <- lm(dat.lm)
dat.lm <- data.frame(y[i], x)
#Locally assign to pass into step function (bug - work around)
assign("dat.lm", dat.lm,  envir = as.environment(1))
assign("efficiency", efficiency,  envir = as.environment(1))
#Non Robust
res.reg <- lm(dat.lm)
if(step.reg){
res.reg <- step.lm(res.reg, data=dat.lm)
}else{
res.reg <- lm(res.reg,data=dat.lm)
}
??step.lm
res.reg <- lm(res.reg,data=dat.lm)
alpha.vec[i] <- coef(res.reg)[1]
beta.mat[i,] <- coef(res.reg)[2:(dim(x)[2] + 1)]
res.mat[,i] <- resid(res.reg)
alpha.vec
beta.mat
res.mat
beta.mat
beta.mat <- ifelse(beta.mat == "NA", 0, beta.mat)
beta.mat
beta.mat.rob
beta.mat <- ifelse(beta.mat == "NA", 0, beta.mat)
beta.mat.rob <- ifelse(beta.mat.rob == "NA", 0, beta.mat.rob)
alpha.vec <- ifelse(alpha.vec == "NA", 0, alpha.vec)
alpha.vec.rob<-ifelse(alpha.vec.rob=="NA",0,alpha.vec.rob)
res.mat
Sigma.mat <- var(res.mat)
Sigma.mat
V
